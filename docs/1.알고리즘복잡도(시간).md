## 알고리즘 복잡도(시간복잡도)

#### 시간복잡도란?
- 알고리즘을 수행하는데 걸리는 시간을 설명하는 계산 복잡도
- 시간복잡도는 입력값 n에 대한 함수로 표현
- 알고리즘의 복잡도 계산 항목은 2가지가 존재한다.
>  - 시간 복잡도: 알고리즘 실행 속도
>  - 공간 복잡도: 알고리즘이 사용하는 메모리 사이즈 <br/>
> <b>가장 중요한 시간 복잡도를 이해하고 계산할 수 있어야 한다.</b>

--- 
#### 알고리즘 시간 복잡도의 주요 요소
- 반복문이 지배한다.
  - 입력값 n에 대해 반복문을 몇 번 실행하는가? 에 따라 시간 복잡도가 결정된다.
---
#### 알고리즘 성능 표기법
- Big O 표기법: O(N)
  - <b>알고리즘 최악의 실행 시간을 표기</b>
  - 가장 많이/일반적으로 사용
  - 아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미

- Ω (오메가) 표기법: Ω(N)
    - <b>알고리즘 최상의 실행 시간을 표기</b>
    - 특정한 상황에서 최상의 성능을 보장한다는 의미

- Θ (세타) 표기법: Θ(N)
  - <b>알고리즘 평균 실행 시간을 표기</b>
  - 평균 시간 복잡도를 표기
  - 알고리즘 평균 실행 시간을 표기
  - <b>최악이나 최선의 상황이 아닌 일반적인 경우</b>를 나타낼 때 사용

> #### Big-O 표기법
>> O(입력): 입력 n 에 따라 결정되는 시간 복잡도 함수 <br/>
>> O(1), O(logn), O(n), O(nlogn), O(n^2), O(n!)(팩토리얼) 등으로 표기한다. <br/> 
>> 입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있다. <br/>
>> - O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n!) <br/>
>>   - 참고: log_n 의 베이스는 2 - log2n
>>> log 란: logarithm 의 약자로, 로그라고 부른다. <br/>
>>> - log2n 의 의미: 2를 몇 제곱해야 n 이 되는가? <br/>
>>> - 일반적으로 표현식으로 나타내면 다음과 같다. <br/>
>>>   - (log_b(a) = c) ====== (b^c = a) <br/>
>>>   - a= 진수, b= 밑수, c= 지수
>>> - 2^4 = 16 일때, log_2(16) = 4 <br/>

* 1 부터 n 까지의 합을 구하는 알고리즘
```java
// 방법 1: 시간 복잡도 O(n)
public class Sum {
    public static void main(String[] args) {
        int n = 100;
        int total = 0;
        for (int i = 1; i <= n; i++) {
            total += i;
        }
        System.out.println(total); //5050
    }
}

// 방법2 : 시간 복잡도 O(1)
public class Sum {
    public static void main(String[] args) {
        int n = 100;
        int total = n * (n + 1) / 2;
        System.out.println(total); //5050
    }
}
```

--- 
